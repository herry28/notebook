#  typescript概述

ts是微软开发的开源的、跨平台的编程语言，是js的超集，最终会被编译为js代码（`任意版本`，兼容性好）。

ts的核心原则：指定`变量`类型，对值所具有的结构进行类型检查

ts的3大特点：

- 始于js，归于js
- 强大的类型系统
- 先进的js

安装ts：

- npm install -g typescript
- tsc -V：测试是否安装成功

vscode自动编译ts：

- tsc --init：生成配置文件tsconfig.json
- 修改tsconfig.json配置
- 启动监视任务：终端--->运行任务--->监视tsconfig.json







# ts编译选项

tsc -w：监视ts文件的变化

tsconfig.json配置文件：

- `include`：定义希望被编译文件所在的目录
- exclude：定义需要排除在外的目录，有默认值，一般不需设置
  - `**`：任意目录
  - `*`：任意文件
- extends：继承
- `compilerOptions`：编译器选项
  -  target：目标，指定ts被编译为ES的版本
  - module：指定模块化规范
  - lib：指定项目中要使用的库，一般不改
  - outDir：指定编译后文件所在目录
  - outFile：将全局作用域中的代码合并为一个文件
  - allowJs：是否对js文件进行编译
  - checkJs：检查js代码是否符合语法规范
  - removeComments：是否移除注释
  - noEmit：不生成编译后的文件
  - noEmitOnError：当有错误时不生成编译后的文件
  - alwaysStrict：设置编译后的文件是否使用严格模式
  - noImplicitAny：不允许隐式的any
  - noImplicitThis：不允许不明确类型的this

## webpack打包ts

```javascript
//webpack.config,js配置文件
module.exports={//webpack中的所有配置信息都写在module.exports中
 entry:"",//指定入口文件
 output:{//指定出口
   path:"",//指定打包文件的目录
   filename:"",//指定打包文件的名称
   environment:{
     arrowFunction:false,//告诉webpack不使用箭头函数
   }
 },
  module:{//指定webpack打包时要使用的模块
    rules:[//指定要加载的规则
      {
        test:"",//指定规则生效的文件
        use:[
          {//配置babel
            loader:"",//指定加载器
            options:{
              presets:[//设置预定义的环境
                [
                  "@babel/preset-env",//指定环境的插件
                  {
                    targets:{//要兼容的目标浏览器
                      "chrome":"88"
                    },
                    "corejs":"3",//指定corejs的版本
                    "useBuildIns":"usage",//使用corejs的方式，usage表按需加载
                  }
                ]
              ]
            }
          }
        ],//要使用的loader
        exclude:"",//要排除的文件
      }
    ]
  },
  plugins:[//配置webpack插件
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title:"",
      template:""//自定义模板
    })
  ],
  resolve:{//用来设置引用模块
    extensions:[],//扩展名
  }
  
}
```







# `变量`类型

ts中变量一开始是什么类型，后期赋值时只能是这个类型的数据，否则报错。

如果`变量`的声明和赋值是`同时`进行的，ts可以`自动`对变量进行类型检测。

如果声明变量时不指定类型，ts解析器会自动判断变量的类型为any（隐式any）

let `变量名：数据类型` = 值

- `字面量`：限制变量的值就是该字面量的值
- boolean
- number
- string
- any：任意类型，相当于对该变量关闭了ts的类型检测
- unknown：类型安全的any，不能直接赋值给其他变量
- void：空值
- never：表永远不会返回结果，不能是任意值；其他类型（包括null、undefined），代表从不会出现的值
  - null、undefined：都可以作为其他类型的子类型，即可把undefined和null赋值给其他类型的变量
- object：任意的js对象
- array：任意js数组
- tuple：固定长度的数组，在定义数组时类型和数据的位置已一一对应
- enum：枚举，枚举里的每个值都可以叫元素(可以是中文)，每个元素有自己的编号，默认从0开始，依次递增

- 联合类型(`|`)：表示取值可以为多种类型中的一种

## 类型别名

`type 别名=类型`

## 类型断言

类型断言：告诉编译器，我知道自己是什么类型，也知道在做什么。即可以用来`手动`指定一个值的类型

- `<类型>值`
- `值 as 类型`

## 类型推断

- 定义变量时没有明确指定类型，会推测出一个类型
  - 定义变量时赋值了，推断为对应的类型
  - 定义变量时未赋值，推断为any类型

## 类型注解

ts中的类型注解是一种轻量级的为函数或变量添加的约束

```typescript
//对象
let obj:{属性：类型，[propName：string]:any}

//数组
let 变量名：数据类型[ ] =  [值1，值2，...] 
let 变量名：Array<数据类型> = [值1，值2，...] 

//函数
let fn:(形参：类型...)=>返回值

//枚举
enum Gender{
  Male:0,
  Femal:1
}
```











# 接口（interface，`以；结束`）

接口是一种类型、一种规范、一种能力、一种约束。

我们使用接口来`定义对象的类型`。即接口是对象的属性和方法的描述。

## 属性类型接口

属性类型接口：对`属性`进行约束

### 可选属性

- ?，放在变量的`后面`
- 好处：
  - 可以对可能存在的属性进行预定义
  - 可以捕获引用了不存在的属性时的错误

### 只读属性

- readonly，放在变量`前面`
- readonly & const：
  - 作为`变量`使用，用const
  - 作为`属性`使用，用readonly



## 函数类型接口

函数类型接口：对`参数及返回值`进行约束。

接口除了可以描述带有属性的普通对象外，还可以描述函数类型和类类型。

函数类型：通过接口的方式作为函数的类型来使用

- 为了使用接口表示函数类型，需要给接口定义一个`调用签名`
- 就像是一个只有参数列表和返回值类型的函数定义，参数列表中的每个参数都需要有名字和类型



## 类类型接口

类类型接口：对`类`进行约束，和抽象类有点相似

类可以通过接口来定义当前类的类型

类可以实现`多个接口`，接口中的内容都要真正的实现

接口与接口之间叫继承（`extends`），接口和类之间叫实现（`implements`）

## 可索引接口

可索引接口：对数组进行约束

```typescript
//类类型接口
interface Animal{
  name:string;
  eat(str:string):void;
}
// 可索引接口
interface arr{
  [index:number]:string //索引值必须为数字，值必须为字符串
}
```







# 类

类中可以定义`属性、构造函数、实例方法、静态方法、静态属性`，类中默认有一个内置的name属性

静态成员：通过`类名.`调用，构造函数不能通过static修饰

- 静态属性：通过static修饰的属性

- 静态方法：通过static修饰的方法

  



## 继承（`extends`）

- 子类（派生类）
- 基类（超类、父类）
- 子类可以调用父类中的构造函数 `super()`
- 子类也可以调用父类中的实例方法 `super.xx()`
- 子类可重写父类的方法



## 多态

多态：父类定义一个方法不去实现，让子类去实现，每个子类有不同的表现

- 父类型的引用指向子类型的对象；不同类型的对象针对相同的方法，产生了不同的行为





## 修饰符

类中成员的修饰符：主要描述类成员（属性、构造函数、方法）的`可访问性`，类中的成员都有自己默认的访问修饰符public。

构造函数的参数也可以使用修饰符修饰，一旦修饰了，该类中就`自动添加`一个`参数属性`。

属性如果不加修饰符，默认是public。

- public：公共的，`类里面、子类、类外面`都可以访问
- private：私有的，类里面可以访问，`子类、类外面都不可以访问`
- protected：受保护的，类里面、子类可以访问，`类外面不可以访问`
- readonly：对类中的属性成员进行修饰，修饰后，
  - 该成员就不能在外部随意的修改
  - `构造函数中，可以`修改只读的属性
  - `实例方法中，不可以`修改只读的属性



## 存取器（读取器：get、设置器：set）

ts通过`getters/setters`可以有效的控制对 对象成员的访问



## 抽象类 & 抽象方法

抽象类和抽象方法用来`定义标准`。

不同于接口，抽象类可以包含成员的实现细节。`abstract`用于定义抽象类和抽象方法。

抽象类：抽象方法（没有任何具体内容的实现并且`必须在子类中实现`）、实例方法。

抽象类作为其它派生类的基类使用，`不能被实例化`

抽象类的目的：为子类服务，子类进行实例化及实现父类的抽象方法。







# 函数

可选参数 ：函数在声明时，参数使用`？`进行修饰，必须放在所有参数的最后

默认参数：函数在声明时，有默认值

剩余参数：...rest，放在所有参数的最后

## 函数重载声明

函数重载：函数名相同，形参不同的多个函数。js中没有函数重载。

```js
const add:(x:number,y:number)=>number=function(x:number,y:number):number{
  return x+y
}
// add：变量名，函数
// (x:number,y:number)=>number:当前函数的类型
// function(x:number,y:number):number{ return x+y} ：符合函数类型的值
```







# 泛型(`<T>`)

泛型就是解决类、接口、函数的`复用性`及对`不特定`数据类型的支持

泛型：在定义函数、接口、类时，不预先指定具体的类型，而在使用时再指定具体类型的一种特性。

泛型变量：

泛型函数：函数中可以有多个泛型的参数。

泛型接口：在定义接口时，为接口中的属性和方法定义泛型类型；在使用接口时，再指定具体的泛型类型

泛型类：在定义类时，为类中的属性和方法定义泛型类型；在创建实例时，再指定特定的泛型类型

泛型约束：若直接对一个泛型参数取length属性会报错，因为这个泛型根本就不知道自己有这个属性，此时需要有一个接口来约束这个泛型，让这个泛型类型   extends   接口

```js
function add<K,V>(value1:K,value2:V):[K,V]{ }
```







# 声明文件

当使用第3方库时，需要引用它的声明文件，才能获得代码补全、接口提示等功能。







# 内置对象 