# typescript概述

ts是微软开发的开源的、跨平台的编程语言，是js的超集，最终会被编译为js代码。

ts的核心原则：

- 对值所具有的结构进行类型检查

ts的3大特点：

- 始于js，归于js
- 强大的类型系统
- 先进的js

安装ts：

- npm install -g typescript
- tsc -V：测试是否安装成功

vscode自动编译ts：

- tsc --init：生成配置文件tsconfig.json
- 修改tsconfig.json配置
- 启动监视任务：终端--->运行任务--->监视tsconfig.json









# 基础类型

ts中变量一开始是什么类型，后期赋值时只能是这个类型的数据，否则报错

let `变量名：数据类型` = 值

- boolean
- number
- string
- null、undefined：都可以作为其他类型的子类型，即可把undefined和null赋值给其他类型的变量
- object
- 数组：数组定义后，里面的数据类型必须和定义数组时是一致的，否则有错误提示信息，编译不通过
  - let 变量名：数据类型[ ] =  [值1，值2，...] 
  - let 变量名：Array<数据类型> = [值1，值2，...] 
- 元组：在定义数组时，类型和数据的位置已一一对应
- 枚举(enum)：枚举里面的每个值都可以叫元素(可以是中文)，每个元素有自己的编号，默认从0开始，依次递增
- any：存储不确定（任意）类型的值，没有智能提示信息
- void：表示`没有任何类型`，在函数声明时，function fn():void{ }，代表该函数没有任何的返回值
- 联合类型(`|`)：表示取值可以为多种类型中的一种
- 类型断言：告诉编译器，我知道自己是什么类型，也知道在做什么。即可以用来`手动`指定一个值的类型
  - <类型>值
  - 值 as 类型
- 类型推断：定义变量时没有明确指定类型，会推测出一个类型
  - 定义变量时赋值了，推断为对应的类型
  - 定义变量时未赋值，推断为any类型





# 类型注解

ts中的类型注解是一种轻量级的为函数或变量添加的约束









# 接口（interface）

接口是一种类型、一种规范、一种能力、一种约束。

我们使用接口来`定义对象的类型`。即接口是对象的属性和方法的描述。



## 可选属性

- ?，放在变量的`后面`
- 好处：
  - 可以对可能存在的属性进行预定义
  - 可以捕获引用了不存在的属性时的错误



## 只读属性

- readonly，放在变量`前面`
- readonly & const：
  - 作为`变量`使用，用const
  - 作为`属性`使用，用readonly



## 函数类型

接口除了可以描述带有属性的普通对象外，还可以描述函数类型和类类型。

函数类型：通过接口的方式作为函数的类型来使用

- 为了使用接口表示函数类型，需要给接口定义一个`调用签名`
- 就像是一个只有参数列表和返回值类型的函数定义，参数列表中的每个参数都需要有名字和类型



## 类类型

类可以通过接口来定义当前类的类型

类可以实现`多个接口`，接口中的内容都要真正的实现

接口与接口之间叫继承（`extends`），接口和类之间叫实现（`implements`）







# 类

类中可以定义`属性、构造函数、实例方法、静态方法、静态属性`，类中默认有一个内置的name属性

静态成员：通过`类名.`调用，构造函数不能通过static修饰

- 静态属性：通过static修饰的属性

- 静态方法：通过static修饰的方法

  



## 继承（`extends`）

- 子类（派生类）
- 基类（超类、父类）
- 子类可以调用父类中的构造函数 `super()`
- 子类也可以调用父类中的实例方法 `super.xx()`
- 子类可重写父类的方法



## 多态

多态：父类型的引用指向子类型的对象；不同类型的对象针对相同的方法，产生了不同的行为



## 修饰符

类中成员的修饰符：主要描述类成员（属性、构造函数、方法）的`可访问性`，类中的成员都有自己默认的访问修饰符public。

构造函数的参数也可以使用修饰符修饰，一旦修饰了，该类中就`自动添加`一个`参数属性`。

- public：公共的，任何位置都可以访问该成员数据
- private：私有的，外部无法访问该成员数据，子类中也无法访问该成员数据
- protected：受保护的，外部无法访问该成员数据，子类中可以访问该成员数据
- readonly：对类中的属性成员进行修饰，修饰后，
  - 该成员就不能在外部随意的修改
  - `构造函数中，可以`修改只读的属性
  - `实例方法中，不可以`修改只读的属性



## 存取器（读取器：get、设置器：set）

ts通过`getters/setters`可以有效的控制对 对象成员的访问



## 抽象类

不同于接口，抽象类可以包含成员的实现细节。`abstract`用于定义抽象类和抽象方法。

抽象类：抽象方法（没有任何具体内容的实现）、实例方法。

抽象类作为其它派生类的基类使用，`不能被实例化`

抽象类的目的：为子类服务，子类进行实例化及实现父类的抽象方法。







# 函数

可选参数 ：函数在声明时，参数使用`？`进行修饰

默认参数：函数在声明时，有默认值

剩余参数：...rest，放在所有参数的最后

## 函数重载声明

函数重载：函数名相同，形参不同的多个函数。js中没有函数重载。



```js
const add:(x:number,y:number)=>number=function(x:number,y:number):number{
  return x+y
}
// add：变量名，函数
// (x:number,y:number)=>number:当前函数的类型
// function(x:number,y:number):number{ return x+y} ：符合函数类型的值
```







# 泛型(`<T>`)

泛型：在定义函数、接口、类时，不预先指定具体的类型，而在使用时再指定具体类型的一种特性。

泛型函数：函数中可以有多个泛型的参数。

泛型接口：在定义接口时，为接口中的属性和方法定义泛型类型；在使用接口时，再指定具体的泛型类型

泛型类：在定义类时，为类中的属性和方法定义泛型类型；在创建实例时，再指定特定的泛型类型

泛型约束：若直接对一个泛型参数取length属性会报错，因为这个泛型根本就不知道自己有这个属性，此时需要有一个接口来约束这个泛型，让这个泛型类型   extends   接口

```js
function add<K,V>(value1:K,value2:V):[K,V]{ }
```







# 声明文件

当使用第3方库时，需要引用它的声明文件，才能获得代码补全、接口提示等功能。







# 内置对象