# 网路基础

## http协议

http协议是基于TCP/IP协议，`一个请求对应一个响应`

请求报文：

- 请求行：请求方式、资源路径、协议版本
- 请求头：`键值对`
- 空行
- 请求体(post)

响应报文：

- 响应行：协议版本、状态码、状态说明
- 响应头
- 空行
- 响应体



## tcp

3次握手：与服务器建立连接

4次挥手：与服务器断开连接







# js基础（==单线程==）

## js数据类型

数据类型分类：

- 基本数据类型：string、number、boolean、null、undefined
  - 基本数据类型的值赋值给某一个变量后，值本身不会再发生改变（==值不可变==）
  - 基于字面量创建出来的值是基本类型
  - 基于构造函数创建出来的值是引用类型
- 引用数据类型：object、array、function、Set
  - 引用数据类型的值赋值给某一个变量后，值可通过其赋值的变量修改（==值可变==）

判断数据类型：

- ==typeof==
  - 返回值有6种：string、number、boolean、undefined、function、object
  - ==null、array==的返回值也为object
- ==instanceof==
  - 用于判断array、function、object
  



## 运算符

- instanceof：当前实例是否是隶属于当前构造函数

- in：检测当前对象是否存在某个属性（稀有属性、公有属性）



## 严格模式

- 变量需用var声明
- 对象不能有重名属性



## JSON对象

- JSON.stringify(obj/arr)：将js对象（数组）转为json对象（数组）
- JSON.parse(json)：将json对象（数组）转为js对象（数组）



## Worker构造函数（h5）

h5规范提供了js分线程的实现，通过Worker构造函数，用于加载分线程执行的js文件

- Worker.prototype.onmessage：用于接收另一个线程的回调函数
- Worker.prototype.postMessage：向另一个线程发送消息

缺点：

- worker内代码不能操作dom（更新ui）
- 不能跨域加载js
- 不是每个浏览器都支持







# 内存

内存：内存条通电后产生的存储空间（==临时的==）

- 产生和死亡：内存条(集成电路板)--->通电--->存储空间--->存储各种数据--->断电--->内存全部消失
- 一块内存包含2个数据：
  - 内部存储的数据（一般数据、地址数据）
  - 内存地址值数据



## js内存分类

- 栈结构内存（==栈结构==）：
  - 先进后出
  - 内存空间小、运行快、使用时分配、且==空间固定==；通常用来保存变量对象
- 堆结构内存（==列表结构==）：
  - 先进先出
  - 空间较大，用来保存对象（对象、函数、数组）







# js事件循环机制

## 进程 & 线程

进程：程序的一次执行，占用一片独有的内存空间（chrome是多进程（打开多个chrome）、多线程(多个界面)）

线程：==CPU的基本调度单位==，是程序执行的一个完整流程

- 一个进程中一般至少有一个运行的线程（==主线程==）
- 一个进程中可以同时运行多个线程，多线程运行的
- 一个进程内的数据可供其中的多个线程直接共享
- 多个进程之间的数据不能直接共享



## js是单线程（主线程）

js代码：

- 同步代码：阻塞的，没有回调
- 异步代码：非阻塞，有回调（用来通知当前异步任务执行的结果）

证明js是单线程：

- alert()



## 事件循环（轮询）机制

- js任务都会在js==主线程==执行
- 当开启一个异步任务时会交给对应的管理模块去管理
- 主线程继续执行后续任务
- 管理模块接管对应的回调，它会在==恰当==的时候将对应的回调放入==回调队列==中
- 当主线程上的所有同步任务执行完，会通过轮询方式询问回调队列是否有可执行的回调
- 若没有，会反复询问
- 若有，将对应的回调==勾==到主线程执行



# 函数

函数也是对象。函数具备行为，可以被调用。

作用：减少代码量；复用；隔离变量、减少命名污染



## 函数定义 

- 函数声明式(命名函数)：function fn () {}

- 函数表达式(匿名函数)：var fn=function () {}



## 函数调用

- fn()
- new Fn()：构造函数调用。若构造函数不需要传递实参，可直接new Fn创建实例
- obj.fn()：对象方式
- fn.call/apply(obj)



## 函数分类

- 普通函数
- 构造函数（类）
  - new操作符：
    - 创建一个空对象
    - 将this指向空对象
    - 执行函数
    - return this
      - 构造函数执行，不写return，浏览器默认返回创建的实例
      - 写了return：
        - 若是基本值，则返回的依然是类的实例
        - 若是引用值，则会把默认返回的实例覆盖
- 匿名函数自调用
  - 隐藏内部实现
  - 不污染外部命名空间
- 回调函数
  - 自己定义的，但没有直接调用，最后执行了（特定条件）



## 函数的this

this是js中的一个==关键字==，一个内置的==引用变量==

函数中的this不是函数定义时决定的。函数中的this指向应该看如何调用该函数。本质上任何函数在执行时都是通过某个对象调用的

this的指向：

- 函数自调用：==window==
- 构造函数：当前构造函数的实例对象
- 对象.方法()：对象
- fn.call() / fn.apply()：指定的对象，是立即调用函数
- fn.bind()：指定的对象，将函数返回



## 原型 & 原型链

### 原型对象：

- 每个==函数==都有一个==prototype==属性（显式原型），在==定义函数==时自动添加的，默认指向一个Object空对象（==原型对象==）

- 每个==对象==都有一个`__proto__`属性（隐式原型），==创建对象==时自动添加的，指向当前实例所属类的prototype
  - 当初设计时不允许操作`__proto__`属性，所以叫隐式原型

- 构造函数的显式原型 = 当前构造函数实例对象的隐式原型

- 原型对象的本质：==普通的Object实例==，初始化时是空对象，后期添加的constructor属性，该属性指向当前函数本身
  - 所有函数都是new Function出来的，包括Function
  - 所有对象都是new Object出来的，包括Object

### 原型对象的作用：

- 构造函数的所有实例对象自动拥有原型对象中的方法和属性

- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上

### 原型链：

原型链：基于`__proto__`向上查找的机制

属性查找规则：

- 查找对象属性时先在==自身==上找
- 若自身没有则沿着`__proto__`查找，若自身的原型对象还没有
- 会沿着`__proto__`继续向上查找，直到找到Object的原型对象，若还没找到则返回undefined

### 原型链 & 作用域链：

- 找==变量==沿==作用域链==，没找到会==报错==

- 找==属性==沿==原型链==，没找到返回==undefined==

- 读取对象属性时会自动到原型链中查找

- 设置对象属性时，不会查找原型链

  

## js引擎工作机制

==js引擎==在js代码正式执行之前会做一些==预解析==的工作：

- 创建执行上下文环境
- 进入当前的执行上下文环境后首先创建一个==变量对象==，用于收集当期执行上下文环境中的==变量、函数、函数参数、this==
  - 先形参赋值
  - 再变量提升 & 函数提升：
    - 找关键字：var、function
    - 找到var后将var后面的变量提前声明，但不赋值
    - 找到function后定义对应的函数（函数在预解析时已经定义完毕）
- 确认this的指向
- ==创建作用域链==

### 预解析：

- 全局预解析
  - 全局预解析在定义函数时==不关心==函数是否被使用
- 函数预解析
  - 函数预解析时，如果==内部函数没有被使用，就不会提前定义==



## 执行上下文栈 & 执行上下文

### 执行上下文栈

在全局代码执行之前，js引擎就会创建一个栈来存储管理==所有的执行上下文（变量对象）==。

- 全局执行上下文（window）创建后，将其添加到栈中（==压栈==）
- 函数执行上下文创建后，将其添加到栈中（==压栈==）
- ==当前函数执行完==后，将栈顶的对象移除（==出栈==）
- 当所有代码执行完后，栈中只剩下window

### 执行上下文

执行上下文是一个==抽象==概念，代表了代码执行的环境，包括：==执行环境、变量对象、this、作用域链==。

执行上下文是==动态==创建的。尤其是针对函数，==函数每调用一次就会创建一次执行上下文，函数执行完就销毁==

执行上下文分类：

- 全局执行上下文
- 函数执行上下文



## 作用域 & 作用域链

作用域分类：

- 静态作用域（词法作用域）：在==代码定义==时就决定了，如js
- 动态作用域：在==代码执行==时决定的，如bash

创建全局作用域--->全局预解析--->全局执行上下文--->全局变量对象

函数定义--->创建函数作用域（函数自身有个[[scopes]]：上一级作用域链）--->函数调用--->预解析--->创建函数执行上下文--->局部变量对象--->创建作用域链（将局部变量对象加入作用域链中）

### 作用域

- 作用域是==抽象==的概念，用来决定代码执行的范围，变量所属的范围。
- 作用域是==代码定义==时决定的。
- 函数执行完毕，函数执行上下文（变量对象）被销毁，但==函数作用域一直在==，除非函数被回收。
- 作用域是==静态的==（相对于执行上下文）
- 作用域分类：
  - 全局作用域
  - 函数作用域：在==函数定义==时就已经确定了，而不是函数调用时
- 作用域作用：
  - 隔离变量
  - 规定当前函数创建之后创建作用域链的上一个链条是什么

### 作用域 & 执行上下文

全局作用域之外，每个函数都会创建自己的作用域。

全局执行上下文是在全局作用域确定后，js代码马上执行之前

函数执行上下文是在函数调用时，函数体代码执行之前创建。

- 作用域是静态的，只要函数定义好了就一直存在，且不会变化
- 执行上下文是动态的，调用函数时创建，函数调用结束时执行上下文自动被释放

执行上下文（变量对象）==从属==于所在的作用域。

### 作用域链

函数在定义时自动添加一个[[Scopes]]属性，该属性保存的是其上级作用域链。当函数执行时，进入执行上下文，将创建的变量对象添加到[[Scopes]]数组中

作用域链是一个==数组==结构，保存的是==变量对象==。

作用域链是在==js代码正式执行之前（预解析）==创建的。

查找变量的规则：

- 先在当前作用域的==变量对象==中查找，如果有就用
- 若没有，就会沿着作用域链的数组去上级作用域中的变量对象中找
- 若还没有则继续向上查找，直到找到最后一个变量对象（全局变量对象），如果还没有就会==报错==



## ==闭包==（跟作用域有关）

闭包是一个==引用关系==，该引用关系存在于==内部函数==中，引用的是==外部函数的局部变量对象==（前提是内部函数使用了外部函数的局部变量）

### 闭包形成的条件

- 函数嵌套
- 内部函数引用外部函数的==局部变量==
- 内部函数==被使用==（若内部函数没有被使用，在函数预解析时==就不会==定义内部函数）

### 常见的闭包

- 将函数作为另一个函数的返回值
- 将函数作为实参传递给另一个函数调用
- 使用闭包实现私有方法操作独立的私有属性
- 立即执行函数

### 闭包优点 & 缺点

优点：

- 延长外部函数变量对象的生命周期
- 可以在函数外部操作到函数内部的数据

缺点：

- 占内存，如果不及时清除容易造成内存溢出，内存泄漏
- 及时清除闭包--->让内部函数成为垃圾对象(没有引用)

### 闭包的生命周期

- 产生：在嵌套内部函数==定义==执行完就产生了（不是在调用）
- 死亡：在嵌套的内部函数成为垃圾对象时







# 数组（有序、容器）

## 数组方法

- 改变原数组（7个）：
  - push()：往数组的最后一个位置追加元素
  - unshift()：往数组的第一个位置追加元素
  - pop()：移除数组中的最后一个元素
  - shift()：删除数组中的第一个元素
  - splice()：删除、添加元素
  - reverse()：数组反转
  - sort()：数组排序
- 不改变原数组：
  - slice()：切割数组
  - concat()：数组拼接
  - join()：把数组用字符串拼接
  - toString()：把数组转为字符串
  - indexOf()：查询某个元素的索引
  - lastIndexOf()：返回最后一个出现的元素索引
  - includes()：判断某个元素是否存在

- 进阶方法
  - forEach(()=>{})：遍历数组，没有返回值
  - filter(()=>{})：过滤出一个新数组（条件为true的元素）
  - map(()=>{})：映射，返回加工后的数组
  - some(()=>{})：用于查询是否有符合条件的`某个`元素，若有，返回true；若没有，返回false
  - every(()=>{})：用于查询数组中每个元素都符合条件，若都符合，返回true；若有一个不符合，则返回false
  - find(()=>{})：查找符合条件的某个元素，返回元素对象
  - findIndex(()=>{})：返回元素的索引







# 对象（无序、容器）

对象是多个数据（key-value）的集合体，便于对多个数据进行统一的管理。



## 对象的组成

- 属性：
  - 属性名：==都是字符串==类型（对象最终保存的key==一定==是字符串，若设置时不是，会调用toString()）
  - 属性值：任意类型
- 方法：是==特殊的属性==，因为属性值是函数



## 访问对象内部数据

- 对象.属性名
- 对象['属性名']，当属性名不是合法的标识名，属性名是变量时



## 创建对象

- Object构造函数
- 工厂模式(return {})，无法确定具体的类型，因为都是Object类型
- ==对象字面量==
- ==构造函数 + 原型对象==



## 对象的静态方法

- Object.create(obj，[descriptors])
  - 以指定对象为原型创建新的对象
  - 为新的对象指定新属性，并对属性进行描述：
    - value：指定值
    - writable：标识当前属性是否可修改，默认为false
    - configurable：标识当前属性是否可被删除，默认为false
    - enumerable：标识当前属性是否能用for in 枚举，默认为false
      - for in除了枚举自身属性，还会枚举原型的属性，通常需跟hasOwnProperty()一起用

- Object.defineProperty(obj，属性，{})

  - 为指定对象定义扩展多个属性



## 对象的实例方法

obj.hasOwnProperty()：检测当前属性是否为对象的私有属性




## ==继承==

- 原型链继承：
  - ==子类的原型==成为==父类的实例==（实例的隐式原型=构造函数的显示原型），需通过constrctor指回构造函数

- 构造函数继承（不是真的继承）：
  - ==子类中通过call（将this改为子类实例）调用父类的方法==

- 组合继承：原型+构造函数

```
Child.prototype=new Parent()
Child.prototype.constructor=Child

Parent.call(this，参数)
```



## 面向对象编程

js中单例模式(字面量)：var obj={}   











# ES6

## let  & const

与var类似，用于声明一个变量。

- 不能重复声明
- 会预处理，有变量提升，但不能提前使用提升的变量
  - 全局变量提升：会创建一个变量对象（script），用于收集全局作用域下let定义的变量，但是没有赋值
  - 函数变量提升：会将var、let定义的变量放到当前函数的变量对象中
- 同var变量提升的区别：let提升的变量在==未赋值前不允许被使用==

const：定义常量，不可以被修改



## 变量的解构赋值

从对象或数组中提取数据，并赋值给变量，以实现==按需索取==

- 对象的解构：按key索取value
- 数组的解构：按index索取value



## 三点运算符

- 剩余参数（...rest）：必须是最后1个形参
- 扩展运算符（拆包）：数组合并、数组克隆、`将伪数组转为真正的数组`



## 字符串的扩展

## 数值的扩展

## 数组的扩展

## 函数的扩展





## 对象的扩展

### 对象的简化写法

- 当key和value同名时，可简写
- 可省略函数的：和function

### 对象的静态方法

- Object.assign()：合并对象
- Object.is()：判断2个值是否完全相等
- Object.setPrototypeOf()：
- Object.getPrototypeOf()：



## Symbol

Symbol是ES6中新增的`原始数据类型`，是一种类似字符串的数据类型

- Symbol属性对应的值是唯一的，解决命名冲突问题
- Symbol值不能与其他类型进行计算
- for in，for of 遍历时不会遍历symbol属性，但可以用Reflect/ownKeys来获取对象的所有键名
- ES6提供了11个内置的symbol值，指向语言内部使用的`方法`

创建symbol：

- let s = Symbol()
- let s = Symbol.for()



## Set(集合、`唯一`)

类似于数组，但成员的值是唯一的，集合实现了iterator接口，所以可以使用扩展运算符和for of遍历

- size：返回集合的元素个数
- add()：添加一个新元素，返回当前集合
- delete()：删除元素，返回布尔值
- has()：检测集合是否包含某个元素，返回布尔值



## Map

类似于对象，也是键值对的集合，但是`键可以是各种类型的值`

- size：返回Map的元素个数
- set()：添加一个新元素，返回当前Map
- get()：返回键名对象的键值
- has()：检测Map是否包含某个元素，返回布尔值
- clear()：清空集合，返回undefined



## iterator（迭代器）& for of

iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制。

对象的==Symbol.iterator==属性指向该对象的==默认遍历器方法==

ES6创造了一种for of循环，iterator接口主要供==for of、三点运算符==使用

iterator工作原理：

- 创建一个指针对象（遍历器对象），指向数据结构的起始位置
- 第一次调用指针对象的next()，指针自动指向数据结构的第一个成员
- 不断调用next()，指针会一直往后移，直到指向最后一个成员
- 每调用一次next()，会返回一个包含value和done的对象
  - value：当前成员的值，当遍历结束时为undefined
  - done：当前的数据结构是否遍历结束，当遍历结束时为true

原生具备iterator接口的数据（可用for of遍历）：

- String
- Array
- arguments
- set容器
- map容器

```js
function iteratorUtil(){//数组的iterator接口（方法/api）
	let index = 0//标识指针起始位置
  let that = this//for of遍历时的目标
  let keys = Object.keys(this)//获取对象中所有key的数组
  if(this instanceof Array){//如果是数组
     return {//生成iterator遍历器对象：有next()方法，next()方法中返回一个包含value和done的对象
      next:function(){
        return index<that.length?{value:that[index++],done:false}:			                                            {value:that[index++],done:true}
    				}
  			}
  }else{//是对象
    return {
      //生成iterator遍历器对象：有next()方法，next()方法中返回一个包含value和done的对象
      next:function(){
        return index<keys.length?{value:that[keys[index++]],done:false}:			                                            {value:that[keys[index++]],done:true}
    			}
    }
  }
}

Array.prototype[Symbol.iterator]=iteratorUtil//为数组的原型部署自己的接口
Object.prototype[Symbol.iterator]=iteratorUtil//为对象的原型部署自己的接口
```



## 生成器函数(*、yield)

执行生成器函数将返回一个`迭代器对象`，然后调用迭代器对象的next()，依次执行生成器中的yield语句。next()的实参将作为上一次yield语句的返回结果。



## Promise构造函数

Promise是一个构造函数（容器），用来封装异步操作，并可以获取其成功或失败的结果。

### promise对象：

- 对象的状态不受外界影响：promise对象代表一个`异步操作`，有3种状态`pending、fulfilled、rejected`，`只有异步操作的结果`才可以`决定当前是哪种状态`
- `一旦状态改变，就不会再变`，任何时候都可以得到这个结果。
  - pending--->fufilled
  - pending--->rejected
    - 只要这2种情况发生，状态就`凝固`了

### promise对象的方法：

- then
  - 第1个then执行完后会执行第2个then（无论成功与否）
  - then里面的函数的返回值，会被下一个then的形参接收
    - 若返回一个promise对象，下一个then的形参接收到的不是promise对象，而是promise对象内部调用`resolve`时传递的`实参`
- catch



## async函数(async、await)

### await

- await后面若跟一个`基本数据类型`，则会将其包装为一个`promise对象`
- await后面若跟一个promise对象，会把`resolve()的实参`返回
- await是`异步的`



## 箭头函数

形参：

- 0个：()不可省略
- 1个：()可省略，也可以不省略
- n个：()不能省略

函数体：

- 1条：{}可省略，当{}省略时会`自动return` 当前语句或表达式的结果
  - 若函数体只有1条语句，且返回一个对象，不建议简写
- n条：{}不可省略，需手动return 指定返回值，否则返回undefined

箭头函数的特点：

- 没有自己的this
  - 箭头函数的this不是调用时决定的，而是==定义==时所处的上下文对象就是它的this
- 不能用作构造函数
- 不能用arguments变量



- 



## class

构造函数：用于定义实例属性，该构造函数实例化对象时自动执行

实例方法

静态方法 & 静态属性（类名调用）

- static：定义静态方法、静态属性

继承：

- extends
- super()：调用父类的constructor函数
- super.xx()：调用父类的实例方法



## ES6模块化



## defineProperty（ES5） & Proxy（ES6）

> 参数1：数据源
>
> 参数2：属性名（该属性不存储数据，只是代理了属性的访问和修改。若需存储，需借助变量）
>
> 参数3：配置对象

```javascript
Object.defineProperty(obj，'属性'，{

	get(){
		return xxx   //访问属性时自动调用，get方法的返回值就是该属性的值
	},
	set(value){//设置属性时自动调用，value为设置的值
		
	}

})
```



## Proxy

> 参数1：数据源
>
> 参数2：配置对象
>
> 返回值：代理对象

```javascript
const p = new Proxy(obj,{
    get(targrt,property){//targrt：被代理的目标对象；property：访问的属性名
        return target[property]
    },
    set(targrt,property,value){
        target[property]=value
    }
})
```



## Reflect