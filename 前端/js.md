# js基础（==单线程==）

## js数据类型

数据类型分类：

- 基本数据类型：string、number、boolean、null、undefined
  - 基本数据类型的值赋值给某一个变量后，值本身不会再发生改变（==值不可变==）
- 引用数据类型：object、array、function
  - 引用数据类型的值赋值给某一个变量后，值可通过其赋值的变量修改（==值可变==）

判断数据类型：

- ==typeof==
  - 返回值有6种：string、number、boolean、undefined、function、object
  - ==null、array==的返回值也为object
- ==instanceof==
  - 用于判断array、function、object







# 内存

内存：内存条通电后产生的存储空间（==临时的==）

- 产生和死亡：内存条(集成电路板)--->通电--->存储空间--->存储各种数据--->断电--->内存全部消失
- 一块内存包含2个数据：
  - 内部存储的数据（一般数据、地址数据）
  - 内存地址值数据



## js内存分类

- 栈结构内存（==栈结构==）：
  - 先进后出
  - 内存空间小、运行快、使用时分配、且==空间固定==；通常用来保存变量对象
- 堆结构内存（==列表结构==）：
  - 先进先出
  - 空间较大，用来保存对象（对象、函数、数组）







# js事件循环机制

## 进程 & 线程

进程：程序的一次执行，占用一片独有的内存空间（chrome是多进程（打开多个chrome）、多线程(多个界面)）

线程：==CPU的基本调度单位==，是程序执行的一个完整流程

- 一个进程中一般至少有一个运行的线程（==主线程==）
- 一个进程中可以同时运行多个线程，多线程运行的
- 一个进程内的数据可供其中的多个线程直接共享
- 多个进程之间的数据不能直接共享



## js是单线程（主线程）

js代码：

- 同步代码：阻塞的，没有回调
- 异步代码：非阻塞，有回调（用来通知当前异步任务执行的结果）

证明js是单线程：

- alert()



## 事件循环（轮询）机制

- js任务都会在js==主线程==执行
- 当开启一个异步任务时会交给对应的管理模块去管理
- 主线程继续执行后续任务
- 管理模块接管对应的回调，它会在==恰当==的时候将对应的回调放入==回调队列==中
- 当主线程上的所有同步任务执行完，会通过轮询方式询问回调队列是否有可执行的回调
- 若没有，会反复询问
- 若有，将对应的回调==勾==到主线程执行



# 函数

函数也是对象。函数具备行为，可以被调用。

作用：减少代码量；复用；隔离变量、减少命名污染



## 函数定义 

- 函数声明式：function fn () {}

- 函数表达式：var fn=function () {}



## 函数调用

- fn()
- new Fn()：构造函数调用
- obj.fn()：对象方式
- fn.call/apply(obj)



## 函数分类

- 普通函数
- 构造函数
  - new操作符：
    - 创建一个空对象
    - 将this指向空对象
    - 执行函数
    - 将执行结果返回
- 匿名函数自调用
  - 隐藏内部实现
  - 不污染外部命名空间
- 回调函数
  - 自己定义的，但没有直接调用，最后执行了（特定条件）



## 函数的this

this是js中的一个==关键字==，一个内置的==引用变量==

函数中的this不是函数定义时决定的。函数中的this指向应该看如何调用该函数。本质上任何函数在执行时都是通过某个对象调用的

this的指向：

- 函数自调用：==window==
- 构造函数：当前构造函数的实例对象
- 对象.方法()：对象
- fn.call() / fn.apply()：指定的对象



## 原型 & 原型链

### 原型对象：

- 每个==构造函数对象==都有一个==prototype==属性（显式原型），在==定义函数==时自动添加的，默认指向一个Object空对象（==原型对象==）

- 每个==实例对象==都有一个`__proto__`属性（隐式原型），==创建对象==时自动添加的
  - 当初设计时不允许操作`__proto__`属性，所以叫隐式原型

- 构造函数的显式原型 = 当前构造函数实例对象的隐式原型

- 原型对象的本质：==普通的Object实例==，初始化时是空对象，后期添加的constructor属性，该属性指向当前构造函数本身
  - 所有函数都是new Function出来的，包括Function
  - 所有对象都是new Object出来的，包括Object

### 原型对象的作用：

- 构造函数的所有实例对象自动拥有原型对象中的方法和属性

- 方法一般定义在原型中，属性一般通过构造函数定义在对象本身上

### 原型链：

沿着`__proto__`这条链就是原型链

- 查找对象属性时先在==自身==上找
- 若自身没有则沿着`__proto__`查找，若自身的原型对象还没有
- 会沿着`__proto__`继续向上查找，直到找到Object的原型对象，若还没找到则返回undefined

### 原型链 & 作用域链：

- 找==变量==沿==作用域链==，找==属性==沿==原型链==

- 读取对象属性时会自动到原型链中查找

- 设置对象属性时，不会查找原型链

  

## js引擎工作机制

==js引擎==在js代码正式执行之前会做一些==预解析==的工作：

- 创建执行上下文环境
- 进入当前的执行上下文环境后首先创建一个==变量对象==，用于收集当期执行上下文环境中的==变量、函数、函数参数、this==
  - 变量提升 & 函数提升：
    - 找关键字：var、function
    - 找到var后将var后面的变量提前声明，但不赋值
    - 找到function后定义对应的函数（函数在预解析时已经定义完毕）
- 确认this的指向
- ==创建作用域链==

### 预解析：

- 全局预解析
  - 全局预解析在定义函数时==不关心==函数是否被使用
- 函数预解析
  - 函数预解析时，如果==内部函数没有被使用，就不会提前定义==



## 执行上下文栈 & 执行上下文

### 执行上下文栈

在全局代码执行之前，js引擎就会创建一个栈来存储管理==所有的执行上下文（变量对象）==。

- 全局执行上下文（window）创建后，将其添加到栈中（==压栈==）
- 函数执行上下文创建后，将其添加到栈中（==压栈==）
- ==当前函数执行完==后，将栈顶的对象移除（==出栈==）
- 当所有代码执行完后，栈中只剩下window

### 执行上下文

执行上下文是一个==抽象==概念，代表了代码执行的环境，包括：==执行环境、变量对象、this、作用域链==。

执行上下文是==动态==创建的。尤其是针对函数，==函数每调用一次就会创建一次执行上下文，函数执行完就销毁==

执行上下文分类：

- 全局执行上下文
- 函数执行上下文



## 作用域 & 作用域链

作用域分类：

- 静态作用域（词法作用域）：在==代码定义==时就决定了，如js
- 动态作用域：在==代码执行==时决定的，如bash

创建全局作用域--->全局预解析--->全局执行上下文--->全局变量对象

函数定义--->创建函数作用域（函数自身有个[[scopes]]：上一级作用域链）--->函数调用--->预解析--->创建函数执行上下文--->局部变量对象--->创建作用域链（将局部变量对象加入作用域链中）

### 作用域

- 作用域是==抽象==的概念，用来决定代码执行的范围，变量所属的范围。
- 作用域是==代码定义==时决定的。
- 函数执行完毕，函数执行上下文（变量对象）被销毁，但==函数作用域一直在==，除非函数被回收。
- 作用域是==静态的==（相对于执行上下文）
- 作用域分类：
  - 全局作用域
  - 函数作用域：在==函数定义==时就已经确定了，而不是函数调用时
- 作用域作用：
  - 隔离变量
  - 规定当前函数创建之后创建作用域链的上一个链条是什么

### 作用域 & 执行上下文

全局作用域之外，每个函数都会创建自己的作用域。

全局执行上下文是在全局作用域确定后，js代码马上执行之前

函数执行上下文是在函数调用时，函数体代码执行之前创建。

- 作用域是静态的，只要函数定义好了就一直存在，且不会变化
- 执行上下文是动态的，调用函数时创建，函数调用结束时执行上下文自动被释放

执行上下文（变量对象）==从属==于所在的作用域。

### 作用域链

函数在定义时自动添加一个[[Scopes]]属性，该属性保存的是其上级作用域链。当函数执行时，进入执行上下文，将创建的变量对象添加到[[Scopes]]数组中

作用域链是一个==数组==结构，保存的是==变量对象==。

作用域链是在==js代码正式执行之前（预解析）==创建的。

查找变量的规则：

- 先在当前作用域的==变量对象==中查找，如果有就用
- 若没有，就会沿着作用域链的数组去上级作用域中的变量对象中找
- 若还没有则继续向上查找，直到找到最后一个变量对象（全局变量对象），如果还没有就会==报错==



## ==闭包==（跟作用域有关）

闭包是一个==引用关系==，该引用关系存在于==内部函数==中，引用的是==外部函数的局部变量对象==（前提是内部函数使用了外部函数的局部变量）

### 闭包形成的条件

- 函数嵌套
- 内部函数引用外部函数的==局部变量==
- 内部函数==被使用==（若内部函数没有被使用，在函数预解析时==就不会==定义内部函数）

### 常见的闭包

- 将函数作为另一个函数的返回值
- 将函数作为实参传递给另一个函数调用
- 使用闭包实现私有方法操作独立的私有属性
- 立即执行函数

### 闭包优点 & 缺点

优点：

- 延长外部函数变量对象的生命周期
- 可以在函数外部操作到函数内部的数据

缺点：

- 占内存，如果不及时清除容易造成内存溢出，内存泄漏
- 及时清除闭包--->让内部函数成为垃圾对象(没有引用)

### 闭包的生命周期

- 产生：在嵌套内部函数==定义==执行完就产生了（不是在调用）
- 死亡：在嵌套的内部函数成为垃圾对象时







# 对象（无序、容器）

对象是多个数据（key-value）的集合体，便于对多个数据进行统一的管理。



## 对象的组成

- 属性：
  - 属性名：==都是字符串==类型（对象最终保存的key==一定==是字符串，若设置时不是，会调用toString()）
  - 属性值：任意类型
- 方法：是==特殊的属性==，因为属性值是函数



## 访问对象内部数据

- 对象.属性名
- 对象['属性名']，当属性名不是合法的标识名，属性名是变量时



## 创建对象

- Object构造函数
- 工厂模式(return {})，无法确定具体的类型，因为都是Object类型
- ==对象字面量==
- ==构造函数 + 原型对象==



## ==继承==

- 原型链继承：
  - ==子类的原型==成为==父类的实例==（实例的隐式原型=构造函数的显示原型），需通过constrctor指回构造函数

- 构造函数继承（不是真的继承）：
  - ==子类中通过call（将this改为子类实例）调用父类的方法==

- 组合继承：原型+构造函数

```
Child.prototype=new Parent()
Child.prototype.constructor=Child

Parent.call(this，参数)
```





# 数组（有序、容器）





# ES6

## Proxy

## Reflect