# 计算机基础

## 计算机硬件

- 控制器
- 运算器(`CPU = 控制器 + 运算器`)
- 存储器（IO设备）：负责数据的存取
  - 内存：基于`电`工作，存取速度快，断电数据丢失，只能临时存取
  - 外存：基于`磁`工作。存取速度慢，断电不会丢失，可永久保存数据
- 输入设备（input）
- 输出设备（output）

一个程序运行与3大核心硬件的关系：

- 程序最先是存放在硬盘中
- 当运行程序时，把程序代码加载到内存中
- cpu从内存中读取指令执行

计算机硬件是`死`的，硬件的运行需要受到软件的控制。软件分为：

- 应用软件：应用程序相关逻辑
- 系统软件：控制底层硬件的

### CPU

CPU的分类与指令集

- 控制其他硬件的指令集
- 运算相关的指令集

x86-64：x86是cpu的型号，64bit指cpu一次性可以从内存中取出`64位二进制指令`，cpu有向下兼容性。

内核态  &  用户态

- 代表CPU的2种工作状态
- 内核态：运行的程序是`操作系统`，可以操作计算机硬件
- 用户态：运行的程序是`应用程序`，不能操作计算机硬件
- 内核态与用户态的转换：
  - 应用程序的运行必然涉及到计算机硬件的操作，那就必须有用户态切换到内核态才能实现，所以计算机工作时在`频繁发生内核态与用户态的转换`。

### 存储器

RAM：内存

ROM：只读内存，用于存放计算机厂商写死的一段核心程序（`BIOS`）

CMOS：耗电量极低，存取速度慢，`断电数据丢失(主板电池)`

硬盘：

- 机械硬盘（磁盘）：
  - 磁道：一圈数据，对应着一串二进制数据
  - 扇区：一个扇区通常为512Bytes，一次性`读写数据的最小`单位（从`硬盘`角度）
    - 一次性读写的单位是1个block块（`1block = 8扇区`）（从`操作系统`角度）
  - 柱面
- 固态硬盘

IO延迟 = 平均寻道时间 + 平均延迟时间，优化程序运行效率的核心：`能从内存取数据，就不要从硬盘取`

- 平均寻道时间：机械手臂转到数据所在磁道需要花费的时间，受理于物理工艺水平，目前机械硬盘可以达到的是5ms
- 平均延迟时间：转半圈的时间，受限于磁盘的转速

虚拟内存

IO设备 = 设备控制器 + 设备本身



## 操作系统

操作系统是一个协调、管理、控制计算机`硬件`资源与`软件`资源的一个控制程序，它位于计算机硬件与应用软件之间，起`承上启下`的作用：

- 控制计算机硬件的基本运行
- 把使用硬件的复杂操作封装成简单的功能，供上层应用程序使用

平台 = 计算机硬件 + 操作系统

### 操作系统安装原理

裸机：CPU、ROM（充当内存，存放BIOS系统），CMOS（充当硬盘，存放BIOS产生的数据）

非裸机：CPU、RAM、硬盘

BIOS---->存有操作系统的光盘---->内存---->拷贝到本地硬盘--->提高本地硬盘的优先级

### 操作系统的启动流程

- 计算机加电
- BIOS开始运行，检测硬件
- BIOS读取CMOS存储器中的参数，选择启动设备
- 从启动设备上读取第1个扇区的内容
- 根据分区信息读入bootloader启动装载模块，启动操作系统
- 操作系统询问BIOS，以获取配置信息。对于每种设备，系统会检查其设备驱动程序是否存在，若没有，系统会要求用户安装设备驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核

### 应用程序的启动流程

- 双击exe快捷方法：exe文件的绝对路径，即告诉操作系统有一个应用程序要执行，应用程序的文件路径
- 操作系统会根据文件路径找到exe程序在硬盘的位置，控制其代码从硬盘加载到内存
- 然后控制cpu从内存中读取应用程序





# 编程思想（范式）

## 面向过程

## 面向对象

## 函数式编程







# python概述

编译型  &  解释型：

- 编译型：执行效率高、开发效率低、跨平台差
- 解释型

强类型 & 弱类型:

- 强类型：变量的数据类型一旦被定义，就不会改变，除非强制转换。
- 弱类型：变量的数据类型可随意切换

动态 & 静态：

- 动态：运行时才进行数据类型检查，即在变量赋值时，就确定了变量的数据类型，不用事先给变量指定数据类型
- 静态：实现给变量进行数据类型定义

python是`解释型的强类型动态`语言。

python：

- python解释器：是基于`c`开发的一个软件，专门用来解释python语言的语法风格并执行
- python语言

## 执行python程序的3个步骤

- `启动python解释器`
- 解释器向操作系统发起系统调用，把.py从硬盘读入内存，此时.py的全部为普通字符，没有任何语法意义
- `解释器`开始执行读入内存的代码，开始`识别`python语法





语法学习的万能法则：

- 是什么？提取知识点名词中的关键字来加以解释

- 为什么要有？让计算机能够具备人的某一种功能/像人一样去做事

- 如何用？

注释：

- #：单行注释
- ''' '''：多行注释

交互：

- print()：
  - %
  - `str.format()`
  - f'{ }'：{ }内可被当做表达式运行
- input()：将用户输入的所有内容都存为`字符串`类型
  - int()：只能将`纯数字`的字符串转成整型







# 变量

变量：可以变化的量，为了让计算机能够像人一样去记忆`一系列状态的变化`

变量需要`先定义，后引用`，由3部分组成：

- 变量名：指向等号右侧值的内存地址，用来访问右侧的值
  -  变量名只能是字母、数字、下划线的任意组合
  - 变量名第1个字符不能是数字
  - `纯小写 + 下划线`、驼峰
- 赋值符号：将变量值的`内存地址`赋值给变量名
- 变量值：记录`事物状态`，有3个重要特征：
  - `id`：`id()`，变量值的`内存地址`，内存地址不同，则id不同。
    - is  & ==   
      - id不同时，值有可能相等；id相同时，值一定相等
      - is：比较左右2个`值id`是否相等
      - ==：比较左右2个`值`是否相等
  - `type`：`type()`，不同类型的值用来记录不同的状态
  - value：值本身

常量：不变的量，python语法中`没有常量`的概念，但在开发中会涉及常量，约定`字母大写`的代表常量

小整数池[-5，256]：

- python解释器`启动那一刻`开始，就会在内存中事先申请好一系列内存空间存放常用的整数
- pycharm扩大了其内存空间

## 数据类型

### int

- 整型，记录整数相关的状态。age=10，底层是age=`int(10)`
- `int()`：可将`纯数字`的字符串转为int；其它进制转10进制
- bin()：10进制转2进制
- oct()：10进制转8进制
- hex()：10进制转16进制

### float

- 浮点型，记录小数相关的状态，底层是调用`float()`

### complex

### str

- str：''、""、''''''，字符串，记录描述性质的状态，底层是调用`str()`。字符串之间可以相加（仅限于str之间），但不推荐使用，因为字符串拼接的效率`极低`
- str()：可将`任意`类型转为字符串
- [ index ]：按索引取值
- [ startIndex：endIndex：step]：切片，`拷贝(浅copy)`一个子字符串
  - 正向步长
  - 反向步长：`[：：-1]`，反转字符串
- len()：统计字符串长度
- in、not in：子字符串是否在大字符串中
- `format()`：格式化字符串
- `strip()`：默认去除首尾空格
- `split()`：切分，返回`列表`
- `join()`：字符串.join()，将元素`全为字符串`的列表拼接为字符串
- `replace()`
- `isdigit()`：判断字符串是否由`纯数字`组成
- `find()`：找不到，`返回-1`
- `index()`：找不到，`抛出异常`
- lower()：转为小写
- upper()：转为大写
- startswith()
- endswith()

### bool

- `True、False`，布尔，记录真假2种状态

### list

- `[ ]`，列表，index---value，记录多个`任意`类型值，并且索引可取指定位置的值。底层是调用`list()`。无论是取值还是赋值，`索引不存在则报错`
- `list()`：类型转换，但凡能被`for循环遍历`的都可被list()转为列表
- `append()`：追加
- `insert()`：插入
- `extend(可迭代对象)`
- `pop()`：根据`索引`删除，不指定索引默认删除最后1个，返回`删除的元素`
  - del：通用的删除方法，`没有返回值`
- remove()：根据`元素`删除，返回None
- count()：统计元素个数
- index()：查找元素索引
- clear()：清空
- reverse()：反转
- `sort()`：排序，默认从小到大
  - 字符串、列表也可以比大小，但对应位置的元素必须是`同种`类型

### tuple

- `（）`，元组，`不可变`(`内存地址`)的 列表，`只读不改`。若元组中只有1个元素，必须加`逗号`。底层是调用`tuple()`。

### dict

- `{ }`，字典，key---value，key必须为`不可变`类型，且`不重复`，通常为`字符串`；value可以为`任意`类型。底层是调用`dict()`。
- fromkeys()：快速初始化字典
- `pop()`：根据key删除元素，返回删除key对应的value值
- `popitem()`：随机删除，返回1个元组（删除的key，删除的value）
- update()
- setdefault()：如果`key有则不添加`，如果没有则添加，返回key对应的值
- `get()`：取值，`key不存在不报错`，返回None
- python2中得到的是列表，python3中得到的是`老母鸡`：
  - keys()
  - values()
  - items()

### set

- { }，用逗号分隔多个元素，底层是调用`set()`，多个元素必须满足3个条件：
  - `不可变`类型
  - `无序`
  - `不重复`
- 集合的作用：
  - `关系运算`
  - 去重（有局限性））：
    - 只能针对`不可变`类型去重
    - `无法保证原来的顺序`
- 交集：`&`
- 并集：`|`
- 差值：`-`
- 对称差值：`^`
- 父子集：>
- 互为父子：==

## 浅拷贝 & 深拷贝

- 浅拷贝（`copy()`）：是把原列表`第一层的内存地址不加区分`的完全copy一份给新列表
- 深拷贝：区分`可变与不可变`类型。不可变类型`内存地址不变`，可变类型产生`新的内存地址`(新瓶装旧酒)
  - 深拷贝针对的是`改`操作
  - import copy
  - copy.deepcopy()

## 直接引用 & 间接引用

python中所有值的传递，传递的都不是值本身，而是`值的引用`，即`内存地址`。

- 直接引用：从栈内存出发，直接引用到值的内存地址，即变量名直接关联变量值
- 间接引用：从栈内存出发，引用到堆内存地址后，进一步引用才能到达的内存地址。即变量名通过`变量值的内存地址`间接关联变量值，只出现在容器中（容器底层存储的是`值的内存地址`）

## 可变类型  &  不可变类型

- 可变类型：`值改变，id不变`，证明`原值`是可以被`改变的`。可变类型是`不可hash`类型。
  - list
  - dict
- 不可变类型：`值改变，id也变`，产生`新值`，压根没有改变原值，证明原值是不可以被修改的。
  - int
  - float
  - str
  - bool
  - tuple







# 垃圾回收机制（GC）

GC是`python解释器自带`的模块，专门用来回收`不可用`的`变量值`所占的`内存空间`。

GC主要运用了`引用计数`来追踪和回收垃圾。在引用计数的基础上，还可以通过`标记-清除`解决容器对象可能产生的循环引用问题，并且通过`分代回收`，以`空间换时间`的方式来进一步提高垃圾回收效率。

## 引用计数

- 引用计数：变量值被变量名关联的次数
- 引用计数减少：
  - `del 变量名`：`解除`变量名和变量值的`引用`关系

## 标记-清除

- 用于解决循环引用，导致内存泄漏问题

## 分代回收







# 基本运算符

## 算数运算符

- /：结果带小数
- //：只保留整数
- %：取模

## 赋值运算符

- =
- 增量赋值：+=、-=、*=、/=
- 链式赋值：x，y=10
- 交叉赋值：m，n=n，m
- 解压赋值：`*_`， *会将没有对应关系的值存成列表，然后赋值给紧跟其后的变量名_。
  - 解压字典时默认解压出来的是字典的key

## 比较运算符

## 逻辑运算符

- not：把紧跟其后的那个条件取反，not与紧跟其后的那个条件是一个`不可分割`的整体
- and：一假则假，
- or：一真则真
  - `not  >  and  >  or`
  - `0、None、False、空`（空字符串、空列表、空字典）所代表的布尔值为False，其余都为真
- 短路运算：`偷懒`原则，偷懒到哪个位置就把`当前位置的值`返回

## 成员运算符

- in
- not in

## 身份运算符

- is

## 位运算







# 流程控制

以下3种可当条件：

- 比较
- True、False
- 隐式布尔值：`0、None、空为False，其它都为True`

`纯计算、无IO`的死循环会导致致命的效率问题

退出循环：

- 将`条件改为假`，`下次`循环判断条件时才生效
- `break`：`立即`终止`本层`循环，嵌套循环时每层都需要break才可退出循环
- continue：终止`本次`循环，`直接`进入下次循环

## if判断

## while循环

- while循环又称`条件`循环，循环次数取决于`条件`
- while + else：`while循环结束后`，并且while循环`没有被break打断时`才会执行else里的代码
  - else：针对`break`

## for循环

- 理论上for循环能做的事，while循环都可以做，但for循环在`遍历取值`比while循环更简洁
- for循环又称`迭代`循环，循环次数取决于in后包含的`值的个数`
- python2中range()返回`列表`，python3中range()返回`迭代器`对象(会下蛋的`母鸡`)
- 可迭代对象：
  - 列表
  - 字典
  - 字符串
  - 元组
  - 集合

```python
if 条件:
	代码...
elif 条件:
  代码...
else:
  代码...

  
while 条件:
  代码...
  

  for 变量名 in 可迭代对象:
    代码...
```







# 函数

函数的使用必须`先定义，后调用`。

`函数名`保存的是`函数的内存地址`，`函数名()`保存的是`函数返回值的内存地址`。

函数定义：定义函数不会执行函数体代码，但会检测函数体语法

- 申请`内存空间保存函数体代码`
- 将`内存空间地址绑定给函数名`

函数调用：函数`没调用之前`可看做`1行代码`

- 通过`函数名找到函数的内存地址`
- `加()触发函数体代码执行`

```python
def 函数名(参数1，参数2，...):
  """文档描述"""
  函数体
  return 值
```

## 函数参数

函数传参的2种方式：

- 直接通过`形参`为函数体传值
- 间接通过`闭包`为函数体传值：当不能直接为函数体传参时，如装饰器，此时需用到闭包传参

形参：定义函数阶段的形式参数，相当于`变量名`

- 位置形参：按从左到右的顺序定义的变量名。`必须被传值`，多一个不行少一个也不行。
- `默认形参`：默认形参的值是在函数定义阶段被赋值的（`值的内存地址`）
  - 位置形参必须在默认形参的前面
  - 虽然默认值可被指定为任意数据类型，但不推荐使用可变类型。若需要，可为其赋值给`None`。因为函数的理想状态是函数的调用只跟函数本身有关，不受外界代码的影响。
- 可变长的`位置形参`：`*args`，用来接收溢出的`位置实参`，溢出部分会被`*`保存成`元组`，然后`赋值给args`
- 可变长的`关键字形参`：`**kwargs`，用来接收溢出的`关键字实参`，溢出部分会被`**`保存成`字典`，然后`赋值给kwargs`
- 命名关键字形参：在定义函数时，`*后定义的参数`。命名关键字实参必须按照key=value的形式为其传值。

实参：调用函数阶段传入的值，相当于`变量值`

- 位置实参：按从左到右的顺序依次传入的值。按顺序与形参`一一对应`
- `关键字实参`：调用函数阶段，按`key=value`的形式传入的值。`指名道姓的给某个形参传值`，可以完全不参照顺序。
  - 位置实参必须在关键字实参前面
  - 不能为同一个形参重复传值
- 可变长的的位置实参：`*实参`(实参可被`for遍历`)，先将 * 后的值`打散`成`位置实参`，再传给形参
- 可变长的的关键字实参：** 实参 (实参必须是`字典`形式)，先将 ** 后的值`打散`成`关键字实参`，再传给形参

形参 & 实参

- 调用阶段，实参（变量值）会绑定给形参（变量名）
- 这种绑定关系只能在`函数体`内使用
- 实参与形参的绑定关系在`函数调用时生效，调用结束后解除绑定关系`

形参混用的顺序：位置形参---默认形参---*args----命名关键字形参---**kwargs

## 函数返回值

return是函数结束的标志，即函数体代码运行一旦遇到return会立即终止函数的运行，并且将return后的值当做本次运行的结果返回。

- 返回None：
  - 函数体没有return
  - return
  - return None
- 返回`一个`值：return 值
- 返回`多个`值：用`逗号`分隔开多个值，会被return返回成`元组`

## 名称空间

`变量名存放在栈区，变量值存放在堆区`。

名称空间：存放名字的地方，是`对栈区的一种虚拟划分`，真正存在的是`栈区`。有了名称空间后，就可以在栈区存放相同的名字，名称空间分为3种：

- `内置`名称空间（`只有1个`）
  - 存放的名字
  - 存活周期：`python解释器启动时`产生，python解释器关闭时销毁。
- `全局`名称空间（`只有1个`）
  - 存放的名字：只要不是函数内定义，也不是内置的，剩下的全是全局名称空间的名字。
  - 存活周期：`运行python文件时`产生，python文件运行完毕后销毁。
- `局部`名称空间（`n个`）
  - 存放的名字：调用函数时，运行函数体代码过程中产生的函数内的名字
  - 存活周期：`调用函数时`产生，函数调用完毕后销毁

名称空间的加载顺序：内存名称空间 > 全局名称空间 > 局部名称空间

名称空间的销毁顺序：内存名称空间 < 全局名称空间 < 局部名称空间

名字查找优先级：

- 基于`名字所处位置`，向上一层一层查找

- 名称空间`只有优先级之分，本身并无嵌套关系`。名称空间的嵌套关系决定了名字的查找顺序。

- 名称空间的`嵌套`关系是以`函数定义`阶段为准，与函数调用无关。即函数的嵌套关系与名字的查找顺序是在定义阶段就已经确定好的。

## 作用域

作用域：变量作用的范围，在名称空间的基础上。

全局作用域 ：`全局存活，全局有效`。

- 内置名称空间 
-  全局名称空间

局部作用域：`临时存活、局部有效`。若想局部修改`全局变量`对应的`不可变类型的值`，需要使用`global`声明`全局变量名`。nonlocal：修改函数外层函数包含的变量所对应的不可变类型的值

- 局部名称空间

## 函数对象

函数对象：可以把函数当做`变量(对象)`使用，保存的是`内存地址`

函数对象的作用：

- 赋值
- 函数的参数
- 函数的返回值
- 容器类型的一个元素

函数对象的属性和方法：

- `__name__`：函数名
- `__doc__`：函数文档信息
- help(函数名)：查看函数文档信息

## 函数嵌套

函数嵌套定义：在函数内定义函数，可用于`递归调用`

函数嵌套调用：在调用函数的过程中又调用其他函数，可用于`装饰器`

## 函数递归调用

一段代码循环运行的方法：

- while、for循环
- 递归调用：
  - `回溯`：一层一层调用下去
  - `递推`：满足某种结束条件，结束递归调用，然后一层一层返回

python对函数的递归调用做了限制，可以使用`sys.getrecursionlimit()`查看递归深度，默认值为1000，虽然可以使用sys.setrecursionlimit()去设定，但仍受主机`操作系统栈大小`的限制，因此不建议

python`不是一门函数式编程语言`，无法对递归进行尾递归优化。

## lambda & 函数式

使用`lambda`关键字定义`匿名函数`，用于临时调用一次的场景，常用于与其他函数配合使用。

语法：`lambda 参数1，参数2...：expression`

- max(obj，key=lambda)，以key为标准判断最大值
- min(obj，key=lambda)，以key为标准判断最小值
- filter(lambda，obj)
- map(lambda，obj)
- sorted

## 闭包函数

`闭包函数 = 名称空间与作用域 + 函数嵌套 + 函数对象`

- 闭包函数的核心：名字的查找是以函数定义阶段为准的

闭包函数（闭包）：

- 闭：该函数是`内嵌函数`
- 包：该函数包含对`外层函数作用域名字的引用`
- `返回闭包函数`

闭包函数的应用：可以为`函数传参`

## 装饰器

装饰器：

- 器指的是工具，可以定义为函数
- 装饰指为其他事物添加额外的东西点缀
- 装饰器指定义一个函数，该函数是用来`为其他函数添加额外的功能`

为何需用装饰器？

- `开放封闭原则`：
  - 开放：指的是对`拓展功能`是开放的
  - 封闭：指的是对`修改源代码`是封闭的
- 装饰器就是在`不修改被装饰对象源代码`以及`调用方式`的前提下，为被装饰对象添加新功能

装饰器的储备知识点：

- *args：
  -  `*`在`形参`：`汇总`成`元组`，并将其赋值给args
  -  `*`在`实参`：将`可被for循环`的`打散`成`位置实参`，然后再传递给形参
- **kwargs
  -  `**`在`形参`：`汇总`成`字典`，并将其赋值给kwargs
  -  `**`在`实参`：将`字典打散`成`key=value`，然后再传递给形参
- 闭包函数：
  - 名称空间与作用域：名称空间的`嵌套`关系是在函数`定义`阶段，即检测语法时确定的。
  - 函数嵌套
  - 函数对象：可以把函数当做`参数`传入，可以把函数当做`返回值`返回

`被装饰对象的参数`，通过`*args,**kwargs`传递；`被装饰对象`，通过`闭包`传递

语法糖：在被装饰对象正上方单独一行写  `@装饰器名`，以实现`偷梁换柱`。

- 偷梁换柱：即将原函数名指向的内存地址偷梁换柱成wrapper函数，所以wrapper函数应该跟原函数一样：
  - 原函数的参数什么样，wrapper的参数就应该什么样
  - 原函数的返回值什么样，wrapper的返回值就应该什么样
  - 原函数的属性什么样，wrapper的属性就应该什么样
- 优先级：函数名()  > @装饰器  

多个装饰器：修饰时`自下而上`修饰，执行时`自上而下`执行

### 无参装饰器

### 有参装饰器

- 第1层参数受被装饰对象参数一致的限制
- 第2层参数受@语法糖的显示
- 第3层参数不受限制

```python
# 语法糖：在被装饰对象正上方单独一行写  @装饰器名，以实现偷梁换柱
# 由于语法糖的限制，outter函数只能有1个参数，用来接收被装饰对象的内存地址
@outter   等价于  fn = outter(fn)


# 无参装饰器模板
from functools import wraps
def outter(fn): #被装饰对象fn，通过闭包传递
  @wraps(fn) #将原函数的属性赋值给wrapper函数
  def wrapper(*args,**kwargs):
  # 1.调用原函数 
  # 2.为其增加新功能
    res = fn(*args,**kwargs)    #调用原函数，被装饰对象的参数，通过*args,**kwargs传递
    return res #将被装饰对象的返回值返回
  return wrapper #将wrapper返回，使其在全局作用域下可用

#有参装饰器
def 有参装饰器(参数):
  def outter(fn):
    def wrapper(*args,**kwargs):
      res = fn(*args,**kwargs)
      return res
    return wrapper
  return outter
```

## 内置函数

- chr()：根据ascii码得到对应字符

- ord()：根据字符得到对应ascii码





# 迭代器 & 生成器 & 生成式

## 迭代器

迭代器指的是`迭代取值`的工具，迭代是一个重复的过程，每次重复都是基于上次的结果，单纯的重复并不是迭代。

为何要有迭代器？

- 为了解决索引取值的局限性，python必须提供一种能够`不依赖索引的取值方式`，即迭代器。

### 迭代器的优缺点

优点：

- 为序列和非序列类型提供了一种`统一的迭代取值`方式
- `惰性计算`：迭代器对象表示一个数据流，可以在需要时才调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有1个值，所以可以存放无限大的数据流

缺点：

- 除非取尽，否则无法获取迭代器的长度
- 只能取下一个值，不能回到开始

### 可迭代对象 & 迭代器对象

可迭代对象：凡是内置有`__iter__()`的对象。有`字符串、列表、元组、字典、集合、文件对象`。

- 可迭代对象.`__iter__()`：得到迭代器对象  

迭代器对象：凡是内置有`__next__()`，并且内置有`__iter__()`的对象。有`文件对象`。

- 迭代器对象.`__next__()`：得到迭代器的下一个值
- 迭代器对象.`__iter__()`：得到迭代器本身（说白了就是调了跟没调一个样）
  - 为什么迭代器对象要有iter方法？为了让for循环可以`统一`处理`可迭代对象和迭代器对象`
  - 为什么文件对象需做成迭代器对象？因为可能一开始文件对象就非常大，所以将其做成迭代器对象，从而`减少内存的占用`

### for循环的工作原理

for循环又称迭代器循环，其工作原理：

1. 调用`__iter__()`，得到一个迭代器对象
2. 迭代器对象.`__next__()`，拿到一个返回值，并将其赋值给k
3. 循环步骤2，直到抛出StopIteration异常，for循环会捕捉异常，然后结束循环

## 生成器（`yield`）

生成器就是`自定义的迭代器`。

在函数体内一旦存在`yield`关键字，调用该函数`不会执行函数体代码`，而是返回一个`生成器对象`。调用生成器.`__next__()`会触发函数体代码运行，遇到yield会停下来，将yield后的值当做本次调用的结果返回。

### 生成器对象的方法

- `__next__()`
- `__iter__()`
- `send()`：用于`给yield传值`，即send()的参数给了yield，再由yield转交给左边的变量
  - `g.send(None)`等同于`next(g)`
- `close()`：关闭之后无法再为yield传值

### `yield`关键字

- 有了yield，就有了一种自定义迭代器的实现方式
- yield可以用于返回值，可返回多次值
- yield可以保存函数的运行状态，`挂起函数`（`yield会从当前挂起的地方接收send()传递过来的值，将其转交给表达式左边的变量；当碰到新的yield时再返回yield后面的值`）

以下方法是等价的：

- len() === `__len__()`

- next() === `__next__()`

- iter() ===`__iter__()`

## 生成式

列表生成式

字典生成式

生成器表达式

```python
# 三元表达式
条件成立时返回的值 if 条件 else 条件不成立返回的值
# 生成器表达式
g=(i for i in iterable if condition) #此时g内部一个值也没有
# 列表生成式
[expression for item in iterable if condition]
# 字典生成式
{key:value for key,value in iterable if condition}
# 集合生成式
{key for key in iterable if condition}

```









# 模块

一个python文件本身就是一个模块，文件名m.py，`模块名m`。

模块是`一系列功能的集合体`，分为3大类：

- 内置模块
- 第三方模块
- 自定义模块

## 模块常识

- `模块名.名字`是指名道姓的问某一个模块要名字对应的值，不会与当前名称空间的名字冲突。
- 无论是查看还是修改，操作的都是`模块本身`，与调用位置无关。
- 自定义模块的命名应采用`纯小写+下划线`
- 模块是第一类对象
- 可以在`函数内导入模块`
- 不建议在1行同时导入多个模块
- 导入模块的规范：
  1. 内置模块
  2. 第三方模块
  3. 自定义模块

## 模块导入

再次导入模块时`不会再造模块名称空间`，而是直接引用首次导入产生的模块名称空间，`不会再执行模块中的代码`

### import 模块名

`首次`导入模块发生3件事：

1. 产生`导入的模块名称空间`
2. `运行`导入的模块，并将运行过程中产生的名字都丢到该空间中
3. 在`当前文件`中产生一个`名字`，该名字指向`模块名称空间`

### from 模块名 import...

`首次`导入模块发生3件事：

1. 产生`导入的模块名称空间`

2. `运行`导入的模块，并将运行过程中产生的名字都丢到该空间中
3. 在当前名称空间拿到一个名字，该名字指向`模块名称空间中的某一个内存地址`

from 模块名 import *：导入模块中所有名字，`__all__`代表 * 控制的名字有哪些

## .py文件的2种用途

- 被当成程序运行：当.py被执行时，`__name__`的值为`__main__`

- 被当做模块导入：当.py被导入时，`__name__`的值为`模块名`

## 搜索模块的路径与优先级

1. 内存（内置模块）

2. 硬盘，按照`sys.path`中存放的文件顺序依次查找要导入的模块

## 包

包只是`模块`的一种形式而已，创建包的目的是为了被导入使用。

python3中，即便包下没有`__init__.py`文件，`import 包`不会报错，python2会报错

### 包的导入

凡是导入时带点的，`点的左边必须是一个包`，否则报错。

- import 包
- from ... import ...

### 绝对导入 & 相对导入

- 绝对导入：以`顶级包`为起始，绝对导入没有任何限制
  - `绝对导入---->sys.path--->执行文件`
- 相对导入：`仅限包内`使用，包内模块之间的导入，一般用相对导入
  - `.`代表当前文件夹
  - `..`代表上级文件夹

## 内置模块

### os（操作系统）

- `os.getcwd()`：获取当前工作目录
- `os.mkdir()`：生成单级目录
- `os.listdir()`：获取某一个文件夹下所有的`子文件及子文件夹`的名字
- `os.system()`：运行shell命令
- `os.environ`：值是一个`字典`，`key与value`必须都为`字符串`。获取系统环境变量
- `os.remove()`：删除一个文件
- `os.rename()`：重命名
- `os.path.getsize()`：获取文件大小
- `os.path.dirname()`：获取文件夹
- `os.path.basename()`：获取文件名
- `os.path.isfile()`：判断是否是文件
- `os.path.isdir()`：判断是否是文件夹
- `os.path.join()`：拼接路径
- os.path.split()：得到文件夹和文件名
- os.rmdir()：删除单级空目录，若目录不为空会报错
- os.chdir()：切换目录
- os.curdir()：返回当前目录
- os.pardir()：获取当前目录的父目录字符串名
- os.makedirs()：递归生成多层目录
- os.removedirs()：若目录为空则删除，并递归到上一级目录，若也为空，则删除

### sys

- `sys.argv`：获取解释器后的参数值，即`命令行参数`，是个`列表`
- `sys.path`：返回模块的搜索路径，是个`列表`，存放了一系列文件夹，其中第一个文件夹是当前`执行文件`所在的文件夹
  - sys.path：列表，用于`导模块`
  - os.environ：字典，整个环境都能用到的
- sys.path.append()：添加到环境变量
  - `__file__`：`当前文件的绝对路径`
  - `os.path.dirname(os.path.dirname(_ _ file _ _))`：当前文件所在的文件夹
- sys.modules：查看已经加载到内存中的模块

### pathlib(python3.5以后的)

```python
from pathlib import Path
root = Path(__ file __)
res=root.parent.parent
```

### time & datetime

time模块将时间分为3种格式：

- 时间戳：从1970年到现在经过的`秒数`，用于时间间隔计算，`time.time()`
- 格式化时间：用于展示时间，`time.strftime('%Y-%m-%d  %H:%M:%S')`
- 结构化时间：用于单独获取时间的某一部分，time.localtime()

时间格式的转换：格式化时间 <--->  结构化时间  <---> 时间戳

- 结构化时间--->时间戳：`time.mktime()`
- 时间戳--->结构化时间：time.localtime()
- 格式化时间--->结构化时间：time.strptime()
- 结构化时间--->格式化时间：time.strftime()

datetime模块：

- datetime.datetime.now()：获取现在的时间
- `datetime.timedelta()`：时间的加减

### random

- random.random()：没有参数，得到`(0，1)`之间的`小数`
- random.uniform(m，n)：得到`(m，n)`之间的`小数`
- random.randint(m，n)：得到`[m，n]`之间的`整数`
- random.randrange(m，n)：得到`[m，n)`之间的`整数`
- random.choice([ ])：随机得到某个值
- random.sample([ ]，n)：随机得到n个值（列表）
- random.shuffle()：随机打乱列表顺序

```python
# 随机得到验证码
def make_code(n):
    res=''
    for i in range(n):
        d=str(random.randint(0,9))
        s=chr(random.randint(65,90))
        res += random.choice([d,s])
    return res
  
 # 打印进度条
def progress(percent):
  if percent>1:
    percent=1
    res=int(50*percent)*'#'
    print('\r[%-50s] %d%%'%(res,int(100*percent)),end='')
```



### shutil

- 高级的文件、文件夹、压缩包处理模块

### json & pickle

序列化 & 反序列化

- 序列化：`内存`中的数据类型--->序列化--->特定的格式写入`磁盘`（json格式或pickle格式）
  - 用于`存储`，可以是一种专用的pickle（python独有）格式
  - 传输给其它平台使用（`跨平台数据交互`），应该是一种通用、能够被所有语言识别

- 反序列化：特定的格式--->反序列化--->内存中的数据类型



#### json

- json.dumps()：将python对象转换为json字符串
- json.dump()：把python对象转换为json字符串，生成一个fp的文件流，与文件有关

#### pickle

### xml

### shelve

### configparser

### hashlib

### suprocess

### logging

### re

## 第三方模块





# 文件处理

## 字符编码

字符编码：`字符与数字`一一对应关系

`内存中固定使用unicode`，我们可以改变的是`存入硬盘`时是哪种编码

`unicode不能直接存到硬盘中`，需要先编码。

`内存中的数据`是可以`修改`的。

`硬盘空间是无法修改`的，硬盘中数据的更新都是用`新内容覆盖旧内容`

老的字符编码都可以转为unicode，但不能通过unicode互转

### ASCII

- `只`支持`英文`字符

- `8位`二进制数对应`1个英文`字符

### GBK

- 支持`英文、中文`字符

- `8位`（8bit=1Bytes）二进制数对应`1个英文`字符(256)
- `16位`（2Bytes）二进制数对应`1个中文`字符(65536)

### unicode

- `兼容`万国字符、与万国字符都有`对应`关系（`中转站`）

- `16位`（2Bytes）二进制数对应`1个字符`(65536)

### utf-8

- 英文：1Bytes
- 中文：3Bytes

### 文本文件存取乱码问题

- 存乱了：编码格式设置为支持文件内容的格式
- 取乱了：文件以什么编码格式存硬盘的，就以什么编码格式读入内存

### 解决python乱码问题

python3解释器默认`读`文件的编码是`ASCII`

python3解释器默认`读`文件的编码是`utf-8`

- 保证python程序前2各阶段不乱码的核心：
  - 指定文件头，修改`读`文件的默认编码：在文件的`首行`，加`#coding：存入硬盘时的编码`
- 保证python程序第3个阶段不乱码的核心：
  - python3的`str`类型默认以`unicode`格式存储，无论如何也不会乱码
  - python2中的str不乱码：u''

### 编码 & 解码

编码：`encode()`，字符---->unicode（内存）--->其他编码（硬盘）

解码：`decode()`，其他编码（硬盘）--->unicode（内存）--->字符



## 文件

文件是`操作系统`提供给用户/应用程序`操作硬盘`的一种虚拟概念/`接口`

- 应用程序对文件的读写请求都是在向`操作系统发起系统调用`，然后由操作系统控制硬盘把输入读入内存、或写入硬盘

## 文件指针

文件内指针的移动都是以`bytes(字节)`为单位的

- 特殊情况：`t`模式下的read(n)，n代表的是`字符`个数

`f.seek(n，模式)`：

- `n`指移动的`bytes`个数
- 模式`0`：参照文件`开头`位置
  - `只有0`可以在t模式下使用，1，2必须在b模式下用
- 模式`1`：参照`当前指针`所在位置
- 模式`2`：参照文件`末尾`位置，应该倒着移动

f.tell()：获取当前文件指针位置

文件修改：

- 将文件内容`一次性`读入内存，然后在`内存中修改`，再`覆盖`写回原文件
  - 在文件修改过程中同一份数据只有一份，但会过多的占用内存
- 一行行读取原文件内容



## open()功能的使用

open()将占用`应用程序资源`（文件对象）和`操作系统资源`（文件）

- f.flush()：立即将文件从内存存到硬盘中
- f.readable()：文件是否可读
- f.writable()：文件是否可写
- f.closed：文件是否关闭
- f.encoding：文件编码
- f.name：文件名

控制文件读写内容的模式：t和b不能单独使用，必须跟r/w/a连用

- t：文本，默认模式
  - 文本文件
  - `读写`都是以`str`（`unicode`）为单位的
  - `必须指定encoding='utf-8'`
    - 没有指定encoding，操作系统会使用自己默认的编码
    - linux默认编码utf-8
    - windows默认编码gbk
- b：二进制
  - `所有`文件
  - `读写`都是以`bytes`为单位的
  - `一定不能指定encoding`

怎么得到bytes类型：

- 若是`纯英文`字符，可以加前缀`b`得到bytes类型
- 若是中文字符，'str'.encode('utf-8')等同于bytes('str'，encoding='utf-8')读出的内容
- b模式下打开文件，f.read()

控制文件读写操作的模式：

- r：只读，当文件不存在时`报错`，当文件存在时文件指针在文件的开头
- w：只写，当文件不存在时会创建文件，当文件存在时会`清空文件`，文件指针在文件的`开头`
- a：只追加写，当文件不存在时会创建空文档，当文件存在时文件指针会文件的末尾

```python
with open(filename,mode='rt',encoding='utf-8') as f:
  for line in f:#循环文件对象
    print(line)
    
  while True:#循环文件对象
    line=f.read(1024)
    if len(line)==0:
      break

      
      
#文件修改1：文本编辑器采用的就是这种方式
with open(filename,mode='rt',encoding='utf-8') as f:
  res=f.read()#一次性将其读取到内存中，在内存中修改后，再将其重新覆盖回磁盘
  data=res.replace('','')
with open(filename,mode='wt',encoding='utf-8') as f1:
  f1.write(data)
  
#文件修改2
import os
with open(filename,mode='rt',encoding='utf-8') as f,\
     open(.filename.swap,mode='wt',encoding='utf-8') as f1:
    		for line in f:
        	f1.write(line.replace('',''))
os.remove(filename)#删除旧文件
os.rename(.filename.swap,filename)#将修改后的文件重命名
```



# 面向对象









# python爬虫

## requests

requests.post()请求时，请求头是由后端决定的。

data参数传参：Content-Type：application/x-www-form-urlencoded

json参数传参：Content-Type：application/json

## 正则

## lxml

## bs4



